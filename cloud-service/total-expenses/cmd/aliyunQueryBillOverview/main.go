package aliyunQueryBillOverview

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	bssopenapi20171214 "github.com/alibabacloud-go/bssopenapi-20171214/v5/client"
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
	_ "github.com/lib/pq"
)

var (
	billingcycle string
	resStr       string
	sqlConnStr   string = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PASSWORD"),
		os.Getenv("POSTGRES_HOST"),
		os.Getenv("POSTGRES_PORT"),
		os.Getenv("POSTGRES_DB"))
)

type AutoGenerated struct {
	Item []struct {
		AdjustAmount          float64 `json:"AdjustAmount"`
		BillAccountID         string  `json:"BillAccountID"`
		BillAccountName       string  `json:"BillAccountName"`
		BizType               string  `json:"BizType"`
		CashAmount            float64 `json:"CashAmount"`
		CommodityCode         string  `json:"CommodityCode"`
		Currency              string  `json:"Currency"`
		DeductedByCashCoupons float64 `json:"DeductedByCashCoupons"`
		DeductedByCoupons     float64 `json:"DeductedByCoupons"`
		DeductedByPrepaidCard float64 `json:"DeductedByPrepaidCard"`
		InvoiceDiscount       float64 `json:"InvoiceDiscount"`
		Item                  string  `json:"Item"`
		OutstandingAmount     float64 `json:"OutstandingAmount"`
		OwnerID               string  `json:"OwnerID"`
		PaymentAmount         float64 `json:"PaymentAmount"`
		PipCode               string  `json:"PipCode"`
		PretaxAmount          float64 `json:"PretaxAmount"`
		PretaxGrossAmount     float64 `json:"PretaxGrossAmount"`
		ProductCode           string  `json:"ProductCode"`
		ProductDetail         string  `json:"ProductDetail"`
		ProductName           string  `json:"ProductName"`
		ProductType           string  `json:"ProductType"`
		RoundDownDiscount     string  `json:"RoundDownDiscount"`
		SubscriptionType      string  `json:"SubscriptionType"`
	} `json:"Item"`
}

func ToSql() {
	data := []byte(Get())
	checkSqlTable(data)
	writeSql(data)
}

// Description:
//
// 使用AK&SK初始化账号Client
//
// @return Client
//
// @throws Exception
func CreateClient() (_result *bssopenapi20171214.Client, _err error) {
	// 工程代码泄露可能会导致 AccessKey 泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考。
	// 建议使用更安全的 STS 方式，更多鉴权访问方式请参见：https://help.aliyun.com/document_detail/378661.html。
	config := &openapi.Config{
		// 必填，请确保代码运行环境设置了环境变量 ALIBABA_CLOUD_ACCESS_KEY_ID。
		AccessKeyId: tea.String(os.Getenv("ALIBABA_CLOUD_ACCESS_KEY_ID")),
		// 必填，请确保代码运行环境设置了环境变量 ALIBABA_CLOUD_ACCESS_KEY_SECRET。
		AccessKeySecret: tea.String(os.Getenv("ALIBABA_CLOUD_ACCESS_KEY_SECRET")),
	}
	// Endpoint 请参考 https://api.aliyun.com/product/BssOpenApi
	config.Endpoint = tea.String("business.aliyuncs.com")
	_result = &bssopenapi20171214.Client{}
	_result, _err = bssopenapi20171214.NewClient(config)
	return _result, _err
}

func _main(args []*string) (_err error) {
	// 判断是否出账
	cstSh, _ := time.LoadLocation("Asia/Shanghai")
	nowTime, _ := strconv.Atoi(time.Now().In(cstSh).Format("20060102"))
	billingcycleTime, _ := strconv.Atoi(time.Now().In(cstSh).Format("200601") + "03")
	if nowTime <= billingcycleTime {
		log.Println("账单未出，请明日再试")
		os.Exit(0)
	}

	//查询上个月账单
	billingcycle = time.Now().AddDate(0, -1, 0).In(cstSh).Format("2006-01")

	client, _err := CreateClient()
	if _err != nil {
		return _err
	}

	queryBillOverviewRequest := &bssopenapi20171214.QueryBillOverviewRequest{
		BillingCycle: tea.String(billingcycle),
	}
	runtime := &util.RuntimeOptions{}
	tryErr := func() (_e error) {
		defer func() {
			if r := tea.Recover(recover()); r != nil {
				_e = r
			}
		}()
		// 复制代码运行请自行打印 API 的返回值
		res, _err := client.QueryBillOverviewWithOptions(queryBillOverviewRequest, runtime)
		if _err != nil {
			return _err
		}
		resStr = res.Body.Data.Items.String()

		return nil
	}()

	if tryErr != nil {
		var error = &tea.SDKError{}
		if _t, ok := tryErr.(*tea.SDKError); ok {
			error = _t
		} else {
			error.Message = tea.String(tryErr.Error())
		}
		// 此处仅做打印展示，请谨慎对待异常处理，在工程项目中切勿直接忽略异常。
		// 错误 message
		fmt.Println(tea.StringValue(error.Message))
		// 诊断地址
		var data interface{}
		d := json.NewDecoder(strings.NewReader(tea.StringValue(error.Data)))
		d.Decode(&data)
		if m, ok := data.(map[string]interface{}); ok {
			recommend, _ := m["Recommend"]
			fmt.Println(recommend)
		}
		_, _err = util.AssertAsString(error.Message)
		if _err != nil {
			return _err
		}
	}
	return _err
}

func Get() string {
	err := _main(tea.StringSlice(os.Args[1:]))
	if err != nil {
		log.Println("func Get()", err)
	}
	return resStr
}

func checkSqlTable(data []byte) {

	var p AutoGenerated
	err := json.Unmarshal(data, &p)
	if err != nil {
		log.Fatalln("解析返回值失败, func(checkSqlTable)", err)
	}

	// 如果不存在表，则新建。
	var tableNameList []string
	for _, i := range p.Item {
		tableNameList = append(tableNameList, i.ProductCode)
	}

	uniqueList := removeDuplicates(tableNameList)

	db, err := sql.Open("postgres", sqlConnStr)
	if err != nil {
		log.Fatalln("连接数据库失败", err)
	}
	defer db.Close()

	rows, err := db.Query("SELECT * FROM pg_tables WHERE schemaname = 'public'")
	if err != nil {
		log.Fatalln("请求sql失败", err)
	}
	defer rows.Close()

	var sqlTableList []string
	for rows.Next() {
		var schemaname string
		var tablename string
		var tableowner string
		var tablespace *string
		var hasindexes string
		var hasrules string
		var hastriggers string
		var rowsecurity string

		err := rows.Scan(&schemaname, &tablename, &tableowner, &tablespace, &hasindexes, &hasrules, &hastriggers, &rowsecurity)
		if err != nil {
			log.Fatalln("获取sql结果失败", err)
		}
		sqlTableList = append(sqlTableList, tablename)
	}

	if err := rows.Err(); err != nil {
		log.Fatalln("查询sql失败", err)
	}

	creatTableName := difference(uniqueList, sqlTableList)
	log.Println("创建表：", creatTableName)
	if len(creatTableName) != 0 {
		for _, v := range creatTableName {
			sqlData := fmt.Sprintf(`
				CREATE TABLE "public"."%s" (
				"BillingCycle" VARCHAR(7) NOT NULL,
				"DeductedByCoupons" NUMERIC NOT NULL,
				"RoundDownDiscount" NUMERIC NOT NULL,
				"ProductName" VARCHAR(200) NOT NULL,
				"ProductDetail" VARCHAR(200) NOT NULL,
				"ProductCode" VARCHAR(200) NOT NULL,
				"BillAccountID" VARCHAR(200) NOT NULL,
				"ProductType" VARCHAR(200),
				"DeductedByCashCoupons" NUMERIC NOT NULL,
				"OutstandingAmount" NUMERIC NOT NULL,
				"BizType" VARCHAR(200),
				"PaymentAmount" NUMERIC NOT NULL,
				"PipCode" VARCHAR(200),
				"DeductedByPrepaidCard" NUMERIC NOT NULL,
				"InvoiceDiscount" NUMERIC NOT NULL,
				"Item" VARCHAR(200),
				"SubscriptionType" VARCHAR(200),
				"PretaxGrossAmount" NUMERIC NOT NULL,
				"PretaxAmount" NUMERIC NOT NULL,
				"OwnerID" VARCHAR(200),
				"Currency" VARCHAR(200),
				"CommodityCode" VARCHAR(200),
				"BillAccountName" VARCHAR(200),
				"AdjustAmount" NUMERIC NOT NULL,
				"CashAmount" NUMERIC NOT NULL
				);`, v)
			rows2, err := db.Query(sqlData)
			if err != nil {
				log.Println(err)
			}
			if err := rows2.Err(); err != nil {
				log.Fatalln("创建表失败", err)
			}
			rows2.Close()
		}
	}
}

func removeDuplicates(list []string) []string {
	unique := make(map[string]struct{})
	for _, item := range list {
		unique[item] = struct{}{}
	}
	result := make([]string, 0, len(unique))
	for item := range unique {
		result = append(result, item)
	}
	return result
}

func intersect(slice1, slice2 []string) []string {
	m := make(map[string]int)
	nn := make([]string, 0)
	for _, v := range slice1 {
		m[v]++
	}

	for _, v := range slice2 {
		times, _ := m[v]
		if times == 1 {
			nn = append(nn, v)
		}
	}
	return nn
}

func difference(slice1, slice2 []string) []string {
	m := make(map[string]int)
	nn := make([]string, 0)
	inter := intersect(slice1, slice2)
	for _, v := range inter {
		m[v]++
	}

	for _, value := range slice1 {
		times, _ := m[value]
		if times == 0 {
			nn = append(nn, value)
		}
	}
	return nn
}

func writeSql(data []byte) {
	var p AutoGenerated
	err := json.Unmarshal(data, &p)
	if err != nil {
		log.Fatalln("解析返回值失败", err)
	}

	db, err := sql.Open("postgres", sqlConnStr)
	if err != nil {
		log.Fatalln("连接数据库失败", err)
	}
	defer db.Close()

	for _, i := range p.Item {
		sqlData := fmt.Sprintf(`INSERT INTO "%s"("BillingCycle", "DeductedByCoupons", "RoundDownDiscount", "ProductName", "ProductDetail", "ProductCode", "BillAccountID", "ProductType", "DeductedByCashCoupons", "OutstandingAmount", "BizType", "PaymentAmount", "PipCode", "DeductedByPrepaidCard", "InvoiceDiscount", "Item", "SubscriptionType", "PretaxGrossAmount", "PretaxAmount", "OwnerID", "Currency", "CommodityCode", "BillAccountName", "AdjustAmount", "CashAmount") VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')`,
			i.ProductCode,
			billingcycle,
			strconv.FormatFloat(i.DeductedByCoupons, 'f', 2, 64),
			i.RoundDownDiscount,
			i.ProductName,
			i.ProductDetail,
			i.ProductCode,
			i.BillAccountID,
			i.ProductType,
			strconv.FormatFloat(i.DeductedByCashCoupons, 'f', 2, 64),
			strconv.FormatFloat(i.OutstandingAmount, 'f', 2, 64),
			i.BizType,
			strconv.FormatFloat(i.PaymentAmount, 'f', 2, 64),
			i.PipCode,
			strconv.FormatFloat(i.DeductedByPrepaidCard, 'f', 2, 64),
			strconv.FormatFloat(i.InvoiceDiscount, 'f', 2, 64),
			i.Item,
			i.SubscriptionType,
			strconv.FormatFloat(i.PretaxGrossAmount, 'f', 2, 64),
			strconv.FormatFloat(i.PretaxAmount, 'f', 2, 64),
			i.OwnerID,
			i.Currency,
			i.CommodityCode,
			i.BillAccountName,
			strconv.FormatFloat(i.AdjustAmount, 'f', 2, 64),
			strconv.FormatFloat(i.CashAmount, 'f', 2, 64))
		rows, err := db.Query(sqlData)
		if err != nil {
			log.Fatalln("sql执行失败: ", err, sqlData)
		}
		if err := rows.Err(); err != nil {
			log.Fatalln("sql执行失败", err)
		}
		rows.Close()
	}
	log.Println("写入数据完成")
}
